(** * Basics_J: Coqにおける関数プログラミング *)

(* このライブラリの定義は、Coq8.3以前のためのもので、現在はCoqに含まれています。
   どうか無視してください。 *)

Definition admit {T: Type} : T.  Admitted.

(** * 導入 *)

(**
  関数型プログラミングのスタイルはプログラミングを数学に近付けます: もしプロシージャやメソッドが副作用を持たないならば、それに関して理解するために必要なものは、入力と出力の対応だけです。すなわち、それらは、数学的な関数を計算するのと全く同じ振舞いであると考えることが出来ます。これは 関数型プログラミングにおいて、"関数型"という単語の一つの理由です。このプログラムと単純な数学的オブジェクトとの直接的な関係は、妥当な非形式的な理由付けと形式的な正当性の証明の両方をサポートします。

  関数型プログラミングが"関数型"である別の意味は、関数(またはメソッド)を_第一級_の値としての使用を重要視することです。すなわち、関数は、他の関数の引数として渡すことが出来る値であり、結果として返されもし、データ構造として格納されます。等々。関数がこのような方法でデータとして扱われうるという認識は、たくさんの有用な表現を可能にします。これからそれを見ていきます。

関数型言語に共通する他の特徴は、_代数的なデータ型_と_パターンマッチ_、それらは、リッチなデータ構造の構築と操作を可能にします。そして、コードの抽象化再利用を可能にする洗練された_多相的な型システム_です。Coqはこれらの特徴を全て備えています。
*)


(* ###################################################################### *)
(** * 列挙型 *)

(** プログラミング言語Coqには、ほとんど何も（ブール型や数値型すら）ビルトインされていません。その代わりCoqには、新しい型やそれを処理するための強力なツールが用意されています。 
 
  当然のことですが、Coqのディストリビューションには、品揃え豊富な標準ライブラリが付属しており、その中で、ブール型、数値型、その他多くのリストやハッシュテーブルに似たデータ構造を提供しています。しかしながら、それらのライブラリ定義のための魔法やプリミティブは存在しません。それらは、通常のユーザコードです。

これがどう動作するか見る為に、とても単純な例から始めましょう。
*)

(* ###################################################################### *)
(** ** 曜日の表し方 *)

(** 次の宣言は、Coqに対して、新しいデータ値のセット（集合）である'型'を定義しています。*)

Inductive day : Type :=
  | monday : day
  | tuesday : day
  | wednesday : day
  | thursday : day
  | friday : day
  | saturday : day
  | sunday : day.

(** その型は[day]で、要素は[monday]、[tuesday]...などです。その定義の1行は以下のようにも読めます。"[monday]は[day]。[tuesday]は[day]"といった具合です。
 
 "[day]"が何かを定義できれば、それを利用して関数を書くこともできるでしょう。 *)

Definition next_weekday (d:day) : day :=
  match d with
  | monday => tuesday
  | tuesday => wednesday
  | wednesday => thursday
  | thursday => friday
  | friday => monday
  | saturday => monday
  | sunday => monday
  end.

(** 一つ注意しておかなければならないことがあります。この関数の定義では、引数の型と戻り値の型が明示されていることです。他の多くの関数型プログラミング言語と同様、Coqはこのように型を明示的に書かずともちゃんと動くようになっています。それはいわゆる「型推論」という機構によって実現されていますが、型を明示した方がプログラムを読みやすくできると判断するなら、いつでもそうしてかまいません。 *)

(** 関数の定義ができたら、いくつかの例を挙げてそれが正しいものであることをチェックしなければなりません。それを実現するために、Coqには三つの方法が用意されています。一つ目は「[Eval compute]」コマンドを使って、関数[next_weekday]を含んだ式を評価させることです。*)

Eval compute in (next_weekday friday).
(* ==> monday : day *)
Eval compute in (next_weekday (next_weekday saturday)).
(* ==> tuesday : day *)

(** もし今手元にコンピュータがあるなら、CoqのIDEのうち好きなもの（CoqIDEやProofGeneralなどから）を選んで起動し、実際に上のコマンドを入力し動かしてみるといいでしょう。付録の「[Basic.v]」ファイルから上のサンプルを探してCoqに読み込ませ、結果を観察してください。 *)

(** 「[compute]」というキーワードは、Coqに対して「我々が与えた式を正確に評価せよ」という命令です。しばらくの間、「[compute]」コマンドは我々にとって必要な唯一のコマンドになるでしょう。この後でもう少し使い出のある別のコマンドを覚えるまでの間ですが。 *)

(** 二番目の方法は、評価の結果として我々が"期待"しているものをCoqに対してあらかじめ以下のような形で例示しておくというものです。 *)

Example test_next_weekday:
  (next_weekday (next_weekday saturday)) = tuesday.

(** この宣言は二つのことを行っています。ひとつは、[saturday]の次の次にあたる平日が、[tuesday]であるということを確認する必要があるということを示すこと。もう一つは、後で参照しやすいように、その確認事項に[test_next_weekday]という名前を与えていることです。
    この確認事項を定義すれば、次のようなコマンドを流すだけで、Coqによって正しさを検証できます。 *)

Proof. simpl. reflexivity.  Qed.

(** この文について細かいことは今は置いておきますが（じきに戻ってきます）、本質的には以下のような意味になります「我々が作成した確認事項は簡約後の両辺の同値チェックによって証明されました。」 *)

(** 三番目の方法は、Coqで[定義]したものから、他のより一般的な言語（OcamlやScheme、Haskellといった）のプログラムを抽出してしまうことです。この機能は今主流の言語で完全に確認されたプログラムを実現できる道を開いたという意味でとても興味深いものです。ここではこの件について深入りすることはしませんが、もしより深く知りたいという場合はCoq'Art book（Bertot and Casteran著）か、Coqリファレンスマニュアルを参照してください。 *)

(* ###################################################################### *)
(** ** ブール型 *)

(** 同様にして、[true]と[false]を値としてとる「[bool型]」を定義することができます。 *)

Inductive bool : Type :=
  | true : bool
  | false : bool.

(**
このようにして、我々は独自のbool型を一から作りあげることもできるのですが、もちろんCoqには標準ライブラリとしてbool型が多くの有用な関数、補助定理と一緒に用意されています。（もし興味があるなら、CoqライブラリドキュメントのCoq.Init.Datatypesを参照してください。）ここでは可能な限り標準ライブラリと正確に同じ機能を、我々独自の名前で定義していくことにしましょう。 *)

(**ブール型を使用する関数は、Day型と同じように定義することができます。 *)

Definition negb (b:bool) : bool :=
  match b with
  | true => false
  | false => true
  end.

Definition andb (b1:bool) (b2:bool) : bool :=
  match b1 with
  | true => b2
  | false => false
  end.

Definition orb (b1:bool) (b2:bool) : bool :=
  match b1 with
  | true => true
  | false => b2
  end.

(** 後半の二つは、引数を複数持つ関数を定義する方法を示しています。 *)

(** 次の四つの単体テストは、関数[orb]が取り得るすべての引数についての完全な仕様（真理値表）となっています。 *)

Example test_orb1:  (orb true  false) = true.
Proof. simpl. reflexivity.  Qed.
Example test_orb2:  (orb false false) = false.
Proof. simpl. reflexivity.  Qed.
Example test_orb3:  (orb false true ) = true.
Proof. simpl. reflexivity.  Qed.
Example test_orb4:  (orb true  true ) = true.
Proof. simpl. reflexivity.  Qed.

(** (注意：上記の証明で[simpl]コマンドを使用しました。それは実際必ずしも必要なものではありません。[reflexivity]コマンドが自動的に単純化を行ってくれるからです。) *)

(** 記述方法について: Coqのコード中にコメントを含める場合には、大括弧を使用してコードと区切ります。この慣習は[coqdoc]というドキュメント作成ツールでも利用されているのですが、ソース中のコメントをコードから視覚的に分離することができます。CoqソースのHTML版では、コメントはソースとは[別のフォント]で表示されます。 *)

(** 次にCoqでのちょっとトリッキーな定義（[admit]）を紹介しましょう。この[admit]は、定義や証明にある不完全な部分を「とりあえず今は無いこと」にしてくれるものです。これを次の[nandb]での練習問題に使ってみることにしましょう。ここからしばらく、練習問題を解くということは[admit]や[Admitted]と書かれた部分をちゃんとした定義や証明に書き直す作業になります。 *)

(** **** 練習問題: ★ (nandb) *)
(** 次の定義を完成させ、[Example]で記述された確認内容がCoqのチェックをすべて通過することを確認しなさい。  *)

(** この関数はどちらか、もしくは両方が[false]になったときに[true]を返すものである。 *)

Definition nandb (b1:bool) (b2:bool) : bool :=
  (* FILL IN HERE *) admit.

(** 下の定義から[Admitted.]を取り去り、代わりに"[Proof. simpl. reflexivity. Qed.]"で検証できるようなコードを記述しなさい。 *)

Example test_nandb1:               (nandb true false) = true.
(* FILL IN HERE *) Admitted.
Example test_nandb2:               (nandb false false) = true.
(* FILL IN HERE *) Admitted.
Example test_nandb3:               (nandb false true) = true.
(* FILL IN HERE *) Admitted.
Example test_nandb4:               (nandb true true) = false.
(* FILL IN HERE *) Admitted.
(** [] *)

(** **** 練習問題: ★ (andb3) *)
(**下にある[andb3]関数も同様に行いなさい。この関数は、全ての引数が[true]のとき、[true]を返し、そうでない場合は、falseを返すべきです。*)

Definition andb3 (b1:bool) (b2:bool) (b3:bool) : bool :=
  (* ここを埋めなさい *) admit.

Example test_andb31:                 (andb3 true true true) = true.
(* FILL IN HERE *) Admitted.
Example test_andb32:                 (andb3 false true true) = false.
(* FILL IN HERE *) Admitted.
Example test_andb33:                 (andb3 true false true) = false.
(* FILL IN HERE *) Admitted.
Example test_andb34:                 (andb3 true true false) = false.
(* FILL IN HERE *) Admitted.
(** [] *)


(* ###################################################################### *)
(**  [Check]コマンドを使うと、Coqに、指定した式の型を表示させることができます。例えば、（[negb true]）という式の全体の型は[bool]である、という具合です。 *)

Check true.
(* ===> true : bool *)
Check (negb true).
(* ===> negb true : bool *)

(** [negb]のような関数は、それ自身が[true]や[false]と同じように値であると考えることもできます。そのようにとらえた場合の値の型を「関数型」と呼び、以下のように矢印を使った型として表します。 *)

Check negb.
(* ===> negb : bool -> bool *)

(** [negb]の型は[bool->bool]と書き、「[bool]から[bool]」と読み、[bool]型の引数をとって[bool]型の戻り値を返す関数と理解することができます。同様に、[andb]の型は[bool -> bool -> bool]と書き、「二つの[bool]型の値を引数として[bool]型の値を作成して戻す」と解釈します。 *)


(** ** 数値 *)

(** ちょっと技術的な話：Coqは大規模な開発を支援するためにちょっと大げさにも見えるモジュールシステムを提供しています。このコースではこれらはほとんど必要のないものですが、一つだけ有用なものがあります。プログラムの中のいくつかの要素を[Module X]と[End X]で囲んでおくと、[End X]以降の部分から、囲まれた中の定義を[X.foo]という風に呼び出すことができます。このことは、新しく[foo]という名前で関数を定義しても問題ないということです。逆に、同じスコープの中では、同じ名前での定義はエラーとなります。という訳で、今回我々はこの機能を使って[nat]という型を内部モジュールとして定義します。そうすることで、標準ライブラリの同じ名前の定義を覆い隠してしまわずに済みます。 *)

Module Playground1.

(** 我々がここまでで定義してきた型は「列挙型」の型定義でした。このような型は、有限の要素をすべて列挙することによって定義されます。型を定義するもう一つの方法は、「帰納的な記述」を並べることで要素を記述する方法です。例えば、自然数は（全て並べるわけにはいきませんが）以下のような方法で定義できます。 *)

Inductive nat : Type :=
  | O : nat
  | S : nat -> nat.

(** この定義の各句は、以下のように解釈できます。
      - [O]は自然数である（[0]（ゼロ）ではなく"[O]"（オー）であることに注意）
      - [S]は自然数を引数にとり、別の自然数を生成する「コンストラクタ」である。このことは、[n]が自然数なら[S n]も自然数であることを示している。

    この定義にして、もう少し詳しく見ていきましょう。

    これまでに定義してきた帰納的な型（[weekday]、[nat]、[bool]など）は、実際には式の集合とでも言うべきものです。[nat]の定義は、[nat]の要素となる式がどのように構築されるかを表しています。

    - 式[O]（オー）は、[nat]に属する。
    - もし[n]が[nat]に属するならば、[S n]もまた[nat]に属する。
    - これら二つの方法で表された式のみが[nat]に属するものの全てである。*)

(** これら三つの条件によって、[nat]が帰納的([Inductive])な方法で厳格に定義されています。この定義によって、式 [O]、式 [S O]、式  [S (S O)]、式 [S (S (S O))]...が全て[nat]に属する式であることが表されています。また同時に、[true]や[andb true false]、[S (S false)]が[nat]に属さないことも明確にされています。

こうして定義された自然数[nat]をマターンマッチにかけることで、簡単な関数を書いてみましょう。例えば、一つ前の[nat]を返す関数は以下のよう書けます。
 *)

Definition pred (n : nat) : nat :=
  match n with
    | O => O
    | S n' => n'
  end.

(** この２番目の句は「もし[n]が何らかの[n']を用いて[S n']と表せるなら、[n']を返す」と読めます。 *)

End Playground1.

Definition minustwo (n : nat) : nat :=
  match n with
    | O => O
    | S O => O
    | S (S n') => n'
  end.

(** 自然数というのは非常に一般的な型なので、Coqは自然数を扱ったり表したりするときに若干特別な扱いをします。[S]や[O]を使った式の代わりに一般的に使われるアラビア数字を使うことができます。実際、Coqは数値を表示する際、デフォルトではアラビア数字を用います。 *)

Check (S (S (S (S O)))).
Eval simpl in (minustwo 4).

(** [nat]のコンストラクタ[S]は、[nat -> nat]型の関数で[minustwo]や[pred]も同様です。 *)

Check S.
Check pred.
Check minustwo.

(** これらが表しているのは、いずれの関数も数を引数にとって数を生成できる、ということです。しかしながらこれらの関数には根本的な違いがあります。[pred]や[minustwo]といった関数には「計算ルール」というものが定義されています。[pred]の定義は、[pred n]が[match n with | O => O | S m' => m' end]のように簡約されることを記述したものですが、一方[S]にはそのような定義がありません。しかし両方とも関数には違いなく、引数を元に評価されるということについては同じで、それ以上のものではないのです。 *)

(** 数値を扱う多くの関数は、単なるパターンマッチだけでは記述できず、再帰的な定義が必要になってきます。例えば、[n]が偶数かどうかを調べて返す関数[evenb]は、[n-2]が偶数であるかどうかを調べる、という再帰的な定義を必要とします。そういう関数を定義する場合、[Fixpoint]というキーワードを使用します。 *)

Fixpoint evenb (n:nat) : bool :=
  match n with
  | O        => true
  | S O      => false
  | S (S n') => evenb n'
  end.

(** Coqがこの定義をチェックする際、[evenb]が再帰的に呼ばれるとき、最初の引数が減少しているかに注目します。これは、ここでいう再帰が[n]について構造的再帰（もしくは原始的再帰）であること、つまり[n]について常により少ない値で再帰呼び出しを行っているか、ということです。これは[evenb]が最終的に停止するということを意味しています。Coqは[Fixpoint]キーワードで定義される関数が常にこの「減少性」を持つことを要求します。 *)

(** 同じように[Fixpoint]を使って関数[oddb]を定義することもできますが、ここでは次のようにもっとシンプルな用法で簡単に作ってみましょう。 *)

Definition oddb (n:nat) : bool   :=   negb (evenb n).

Example test_oddb1:    (oddb (S O)) = true.
Proof. simpl. reflexivity.  Qed.
Example test_oddb2:    (oddb (S (S (S (S O))))) = false.
Proof. simpl. reflexivity.  Qed.

(** 当然ながら、引数を複数持つ関数も再帰的に定義することができます。 *)

(** ネームスペースを汚さないようにするため、別のモジュールに定義することにしましょう。*)
Module Playground2.

Fixpoint plus (n : nat) (m : nat) : nat :=
  match n with
    | O => m
    | S n' => S (plus n' m)
  end.

(** 3に2を加えた結果は、5になるべきですね。 *)

Eval simpl in (plus (S (S (S O))) (S (S O))).

(** Coqがこの計算をどう進めて（簡約して）結論を導くかは以下のように表現できます。 *)

(**     [plus (S (S (S O))) (S (S O))]    *)
(**    ==> [S (plus (S (S O)) (S (S O)))]    by the second clause of the [match]*)
(**    ==> [S (S (plus (S O) (S (S O))))]    by the second clause of the [match]*)
(**    ==> [S (S (S (plus O (S (S O)))))]    by the second clause of the [match]*)
(**    ==> [S (S (S (S (S O))))]             by the first clause of the [match]  *)

(** 表記を簡便にするため、複数の引数が同じ型を持つときは、型の記述をまとめることができます。 [(n m : nat)]は[(n : nat) (m : nat)]と書いたのとまったく同じ意味になります。 *)

Fixpoint mult (n m : nat) : nat :=
  match n with
    | O => O
    | S n' => plus m (mult n' m)
  end.

(** matchに引数を与える際、複数の引数を次のようにカンマで区切って一度に渡すことができます。 *)

Fixpoint minus (n m:nat) : nat :=
  match n, m with
  | O   , _    => O
  | S _ , O    => n
  | S n', S m' => minus n' m'
  end.

(** [minus]の[match]の行に現れる( _ )は、ワイルドカードパターンと呼ばれるものです。パターンの中に _ を書くと、それはその部分が何であってもマッチし、その値が使用されないことを意味します。この _ は、このような場合に無意味な名前をつける必要をなくしてくれます。 *)

End Playground2.

Fixpoint exp (base power : nat) : nat :=
  match power with
    | O => S O
    | S p => mult base (exp base p)
  end.

Example test_mult1:             (mult 3 3) = 9.
Proof. simpl. reflexivity.  Qed.

(** **** 演習問題: ★ (factorial) *)
(** 再帰を使用した、一般的なfactorical（階乗）の定義を思い出してください :
<<
    factorial(0)  =  1
    factorial(n)  =  n * factorial(n-1)     (if n>0)
>>
    これをCoqでの定義に書き直しなさい。 *)

Fixpoint factorial (n:nat) : nat :=
  (* FILL IN HERE *) admit.

Example test_factorial1:          (factorial 3) = 6.
(* FILL IN HERE *) Admitted.
Example test_factorial2:          (factorial 5) = (mult 10 12).
(* FILL IN HERE *) Admitted.
(** [] *)

(** ここで紹介する"notation"（表記法）という機能を使うことで、加算、減算、乗算のような数値を扱う式をずっと読みやすく、書きやすくすることができます。 *)

Notation "x + y" := (plus x y)  (at level 50, left associativity) : nat_scope.
Notation "x - y" := (minus x y)  (at level 50, left associativity) : nat_scope.
Notation "x * y" := (mult x y)  (at level 40, left associativity) : nat_scope.

Check ((0 + 1) + 1).

(** これらは、これまで我々が定義してきたものを何ら変えるわけではありません。NotationはCoqのパーサに対して[x + y]を[plus x y]と解釈させたり、逆に[plus x y]を[x + y]と表記させたりするためのものです。

各表記法のシンボルは、表記法のスコープ内でのみ有効です。Coqはどのスコープであるかを推測しようとします。[S(O*O)]と書かれていた場合は、それを[nat_scope]であると推測しますし、ソースにデカルト積（タプル）型[bool*bool]と書かれていたら、[type_scope]であると推測します。時には[(x*y)%nat]といった風に、%表記を使ってスコープを明示する必要があるでしょうし、どの表記スコープで解釈したかが[%nat]というような形でCoqからフィードバックされてくることもあります。

表記のスコープは、多くの場合数値に適用されます。ですので[0%nat]という表記を[O]（オー）や[0%Z]（数値のゼロ）という意味で見ることがあります。 *)

(** 最初の方で、Coqにはほとんど何も用意されていない、という話をしましたが、本当のところ、数値を比較する関数すら自分で作らなければならないのです！! *)
(** [beq_nat]関数は自然数を比較してbool値を返すものです。入れ子になった[match]に気をつけて、以下のソースを読んでください。（二つの変数を一度に[match]させる場合の書き方は、[minus]のところですでに登場しています） *)

Fixpoint beq_nat (n m : nat) : bool :=
  match n with
  | O => match m with
         | O => true
         | S m' => false
         end
  | S n' => match m with
            | O => false
            | S m' => beq_nat n' m'
            end
  end.

(** 同様に、[ble_nat]関数は自然数を比較して小さいか等しい、ということを調べてbool値を生成し返します。 *)

Fixpoint ble_nat (n m : nat) : bool :=
  match n with
  | O => true
  | S n' =>
      match m with
      | O => false
      | S m' => ble_nat n' m'
      end
  end.

Example test_ble_nat1:             (ble_nat 2 2) = true.
Proof. simpl. reflexivity.  Qed.
Example test_ble_nat2:             (ble_nat 2 4) = true.
Proof. simpl. reflexivity.  Qed.
Example test_ble_nat3:             (ble_nat 4 2) = false.
Proof. simpl. reflexivity.  Qed.

(** **** 練習問題: ★★ (blt_nat) *)
(** [blt_nat]関数は、自然数を比較して小さい、ということを調べてbool値を生成します（ [nat]ural numbers for [l]ess-[t]han）。[Fixpoint]を使用して１から作成するのではなく、すでにこれまで定義した関数を利用して定義しなさい。

注：[simpl]タクティックを使ってうまくいかない場合は、代わりに[compute]を試してください。それはよりうまく作られた[simpl]と言えるものですが、そもそもシンプルでエレガントな解が書けていれば、[simpl]で十分に評価できるはずです。 *)

Definition blt_nat (n m : nat) : bool :=
  (* FILL IN HERE *) admit.

Example test_blt_nat1:             (blt_nat 2 2) = false.
(* FILL IN HERE *) Admitted.
Example test_blt_nat2:             (blt_nat 2 4) = true.
(* FILL IN HERE *) Admitted.
Example test_blt_nat3:             (blt_nat 4 2) = false.
(* FILL IN HERE *) Admitted.
(** [] *)


(** * 簡約を用いた証明 *)

(** ここまでに、いくつかの型や関数を定義してきました。が、ここからは少し目先を変えて、こういった型や関数の特性や振る舞いをどうやって知り、証明していくかを考えてみることにしましょう。実際には、すでにこれまでやってきたことでも、その一部に触れています。例えば、前のセクションの[Example]は、ある関数にある特定の値を入力した時の振る舞いについて、あらかじめ想定していたものと正確に一致していると主張してくれます。それらの主張が証明しているものは、以下のものと同じです。

[=]の両側の式を定義に基づいて簡約した結果は、一致している。

(実際、[reflexivity]は[simpl]よりいくぶん多くのことをやってくれるので、覚えておくと後々便利でしょう。例えば、[reflexivity] は定義された句を展開したり、右辺と置き換えるといったことを試みます。この違いから、[reflexivity] が向いているのは、「[reflexivity] によって全てのゴールが自動的に証明され、[reflexivity] が見つけて展開した式をあえて見なくてもよい」という場合で、逆に[simpl]は、我々自身が新しいゴールを読んで理解すべき時（勝手に定義を展開し解釈して欲しくない時）に向いているということになります)

このような「簡約を用いた証明」は、関数のさらに興味深い性質をうまく証明することができます。例えば、[0]が自然数の加算における左単位元（[0]が、左から加えても値が変わらない値であること）であることの証明は、[n]が何であっても[0 + n]を注意深く縮小(簡約)したものが[n]になることを、[+]という関数が「最初の引数を引き継いで再帰的に定義されている」ということを考慮した上で示せればいいということです。 *)

Theorem plus_O_n : forall n:nat, 0 + n = n.
Proof.
  simpl. reflexivity.  Qed.

 (** _注意_:上記の式が元のソースファイルと最終的なhtml出力とで、違って見えることに気がついたかもしれません。Coqのファイルにおいて、予約語である_forall_を使って[forall]全称修飾子を書く必要があります。これは論理学でよく使用される、引っくり返った"A"としてプリントされます。*)
  
(** この定理と証明の形式の形式はほとんど上記の例と同じですが、僅かに違いがあります。*)
  
(* 一つは、[Exmaple]の代わりに[Theorem]キーワードを使用しています。確かにこれは単なるスタイルの違いで、[Example]と[Theorem]（他にも[Lemma]、[Fact]、[Remark]など）はCoqから見るとすべて同じ意味を持ちます。

二つめは、量化子が加えられている（[forall n:nat]）ことです。そのため我々の定理は_全ての_自然数[n]ついて語っています。この形式の定理を証明するために、任意の自然数[n]の存在を前提とすることで理由付け出来なければなりません。これは[intros n]で証明を開始することで行います。[intros n]は量化子をゴールから現在の仮定の"コンテキスト"に引き上げます。実際、我々も証明を「よし、nを任意の数値としよう」と言って始めます。*)

(** [intros]や[simpl]や[reflexivity]キーワードはタクティックのタクティックの例です。タクティックは、[Proof]と[Qed]の間に記述され、Coqに対して、我々がしようとしている主張の正当性をどのようにチェックすべきかを指示するためのコマンドです。この講義の残りでは、まだ出てきていないタクティックのうちのいくつかを紹介していきましょう。さらにその後の講義ではもっと色々出てくるのですが。*)

(** これらの証明をCoq上で逐次実行し、どのようにゴールやコンテキストが変化するのかをよく観察してください *)

Theorem plus_1_l : forall n:nat, 1 + n = S n.
Proof.
  intros n. reflexivity.  Qed.

Theorem mult_0_l : forall n:nat, 0 * n = 0.
Proof.
  intros n. reflexivity.  Qed.

(** 定理の名前についている[_l]という接尾辞は、「左の」と読みます。 *)

(* ###################################################################### *)
(** * 書き換え（[Rewriting]）による証明*)

(** 少しばかり興味深い定理を見てみましょう。 *)

Theorem plus_id_example : forall n m:nat,
  n = m ->
  n + n = m + m.

(** この定理は、あらゆる[n]や[m]について完全に成り立つと言っているわけではなく、[n = m]が成り立つときに限って成立する、というもので、この矢印は"ならば"と一般的に読みます。

[n]と[m]が両方とも任意の数なのですから、これをこれまでの証明でやってきたように簡約することはできません。その代わりに、[n = m]ならば、イコールの両側の[n]や[m]を互いに書き換えても等しさは変わらない、というところに注目します。このような書き換えをしてくれるのが[rewrite]タクティックです。 *)

Proof.
  intros n m.   (* move both quantifiers into the context *)
  intros H.     (* move the hypothesis into the context *)
  rewrite -> H. (* Rewrite the goal using the hypothesis *)
  reflexivity.  Qed.

(** 証明の1行目は、∀（forall）がついた、つまり「あらゆる[n],[m]について」の部分をコンテキストに移しています。2行目は、[n = m]ならば、という仮定をコンテキストに写し、[H]という名前をこれに与えています。3行目は、ゴールになっている式([n + n = m + m])に仮定[H]の左側を右側にするような書き換えを施しています。

（[rewrite]の矢印は特に論理に関与していません。単に左側を右側に置き換えているだけです。逆に右側を左側に置き換えたい場合は、[rewrite <-]と書くこともできます。この逆の置き換えも上の証明で試して、Coqの振る舞いがどのように変わるかを観察してください。） *)

(** **** 練習問題: ★ (plus_id_exercise) *)
(** [Admitted.]を削除し、証明を完成させなさい。*)

Theorem plus_id_exercise : forall n m o : nat,
  n = m -> m = o -> n + m = m + o.
Proof.
  (* FILL IN HERE *) Admitted.
(** [] *)

(** 以前の例で見たように、Admittedコマンドは、Coqに対して「この証明はあきらめたので、この定理はこれでいいことにしてください」と指示するものです。この機能は、より長い証明をする際に便利です。何か大きな論証をしようとする時、今のところ信用している補足的な命題を示したい時があります。そんな時、[Admitted]を使用すると、その命題を一時的に信用できることにして、それを踏み台にしてより大きな論証を進めることができるのです。そしてそれが完成したのち、あらためて保留していた命題の証明を埋めればいいのです。ただし注意して下さい。[admit]や[Admitted]を使用することは、一時的にドアを開けて、「全て形式的なチェックを受け証明済みの、信用するに足るCoqの世界」から、信用に値しない下界へ足を踏み出していることに他なりません。いつかは戻ってドアを閉めることがお約束です！*)

(** 仮定の代わりに、前もって証明された定理を使っても[rewrite]タクティックは同じように利用することができます。 *)

Theorem mult_0_plus : forall n m : nat,
  (0 + n) * m = n * m.
Proof.
  intros n m.
  rewrite -> plus_O_n.
  reflexivity.  Qed.

(** **** 練習問題: ★★, recommended (mult_1_plus) *)
Theorem mult_1_plus : forall n m : nat,
  (1 + n) * m = m + (n * m).
Proof.
  (* FILL IN HERE *) Admitted.
(** [] *)

(** * Case分析 *)

(** もちろん、どんな命題でも簡単な計算だけで証明できるという訳ではありません。一般に、未知だったり仮定の（任意のbool、自然数、リストなど）値は、我々が検証しようとしている関数の先頭に記述され、それが簡約の邪魔をしてくれます。例えば、下のような命題をsimplタクティックだけで証明しようとすると、すぐに行き詰まってしまうでしょう。 *)

Theorem plus_1_neq_0_firsttry : forall n : nat,
  beq_nat (n + 1) 0 = false.
Proof.
  intros n. simpl.  (* does nothing! *)
Abort.

(** その原因は、beq_natと+の定義で、共に最初の引数が[match]に渡されていることです。つまり、[+]に渡す最初の引数は[n]という未知数な上に、[beq_nat]の引数は[n + 1]という複合式になっているため、そのまま簡約できないのです。

今求められていることは、[n]を何らかの条件に分割し、先に進めそうな形にすることができないかを検討することです。もし[n]が[O]なら、[beq_nat (n + 1) 0]の結果を得ることはできます。もちろん結果は[false]です。しかしもし[n]が何かの[n']を使って[n = S n']と表せると考えても、我々は[n + 1]の値を得ることはできません。ただ、その式が一つの[S]で始まる（始まらないものは[O]にマッチする）ことに着目すると、[beq_nat]の結果を計算して値を求めることができます。その結果結果[beq_nat (n + 1) 0]は、やはり[false]になるでしょう。

このことから、求められるタクティックはCoqに[n = O]の場合と[n = S n']の場合に分けて考えるように要求するもので、それは[destruct]と呼ばれます。 *)

Theorem plus_1_neq_0 : forall n : nat,
  beq_nat (n + 1) 0 = false.
Proof.
  intros n. destruct n as [| n'].
    reflexivity.
    reflexivity.  Qed.

(** [destruct]タクティックは二つのサブゴールを作ります。その両方を別々に、Coqを使って定理として証明していくことになります。一つのサブゴールからもう一つへ移動するための特別なコマンドは必要ありません。一つ目のサブゴールが証明されれば、それは消えて自動的にもう一つのサブゴールにフォーカスが移ります。この証明では、二つに分かれたサブゴールのいずれも[reflexivity]を1回使うだけで簡単に証明できます。

destructについている注釈"[as [| n']]"は、"イントロパターン"と呼ばれるものです。これはCoqに対して、両方のサブゴールに元[n]だった変数をどのような変数名を使って取り入れるかを指示するものです。一般的に[[]]の間にあるものは"名前のリスト"で、"[|]"によって区切られます。このリストの最初の要素は空ですが、これは[nat]の最初のコンストラクタである[O]が引数をとらないからです。二つ目のコンストラクタ[S]は引数を一つ取りますので、リストの二つ目の要素である[n']を名前に使用します。

[destruct]タクティックは帰納的に定義された型に対して使用できます。例えば、bool値の否定が反射的であること・・・つまり否定の否定が元と同じになることを証明してみましょう。 *)

Theorem negb_involutive : forall b : bool,
  negb (negb b) = b.
Proof.
  intros b. destruct b.
    reflexivity.
    reflexivity.  Qed.

(** ここで使われている[destruct]には[as]句がありませんが、ここで展開している[b]の型[bool]の二つのコンストラクタが両方とも引数をとらないため、名前を指定する必要がないのです。このような場合、"[as [|]]"や"[as []]"のように書くこともできます。実際のところほとんどの場合[destruct]の[as]句は省略可能です。その際はCoqの側で自動的に変数名をつけてくれます。これは確かに便利なのですが、よくない書き方とも言えます。Coqはしばしば名前付けに混乱して望ましくない結果を出す場合があります。 *)

(** **** 練習問題: ★ (zero_nbeq_plus_1) *)
Theorem zero_nbeq_plus_1 : forall n : nat,
  beq_nat 0 (n + 1) = false.
Proof.
  (* FILL IN HERE *) Admitted.
(** [] *)

(* ###################################################################### *)
(** * さらなる練習問題 *)

(** **** 練習問題: ★★ (boolean functions) *)
(** bool型を扱う関数についての以下の定理を証明するために、これまでに学習したタクティックを使いなさい。*)

Theorem identity_fn_applied_twice :
  forall (f : bool -> bool),
    (forall (x : bool), f x = x) ->
      forall (b : bool), f (f b) = b.
Proof.
(* FILL IN HERE *) Admitted.

(** 上記の定理によく似ているけれど、二つめの仮定で関数[f]が [f x = negb x].という性質を持つ、 [negation_fn_applied_twice]という定理を書いて証明しなさい。*)

(* FILL IN HERE *)

(** **** 練習問題: ★★ (andb_eq_orb) *)
(* 次の定理を証明しなさい。(おそらく補助的な定理を一つか二つ証明したくなると思います。)*)

Theorem andb_eq_orb :
  forall (b c : bool),
    (andb b c = orb b c) ->
    b = c.
Proof.
(* FILL IN HERE *) Admitted.

(** **** 練習問題: ★★★ (binary) *)
(** これまでとは異なる、通常表記の自然数ではなく2進のシステムで、自然数のより効率的な表現を考えなさい。それは自然数をゼロとゼロに1を加える加算器からなるものを定義する代わりに、以下のような2進の形で表すものです。2進数とは、
      - ゼロであるか,
      - 2進数を2倍したものか,
      - 2進数を2倍したものに1を加えたもの.

    (a) まず、以下のnatの定義に対応するような2進型[bin]の帰納的な定義を完成させなさい。
    (ヒント: [nat]型の定義を思い出してください。
[[
    Inductive nat : Type :=
      | O : nat
      | S : nat -> nat.
]]
    nat型の定義[O]や[S]の意味が何かを語るものではなく、（[O]が実際に何であろうが）[O]がnatであって、[n]がnatなら[S]が何であろうと[S n]はnatである、ということを示しているだけです。「[O]がゼロで、[S]は1を加える」という実装がそれを自然数としてみて実際に関数を書き、実行したり証明したりしてみてはじめて実際に意識されます。ここで定義するbinも同様で、次に書く関数が書かれてはじめて型binに実際の数学的な意味が与えられます。)

    (b) 先に定義したbin型の値をインクリメントする関数を作成しなさい。また、bin型をnat型に変換する関数も作成しなさい。

    (c) 最後にbで作成したインクリメント関数と、2進→自然数関数が可換であることを証明しなさい。これを証明するには、bin値をまずインクリメントしたものを自然数に変換したものが、先に自然数変換した後にインクリメントしたものの値と等しいことを証明すればよい。
*)

(* FILL IN HERE *)
(** [] *)

(* ###################################################################### *)
(** * 付録資料 *)

(** ** 記法についてもう少し *)

Notation "x + y" := (plus x y)
               (at level 50, left associativity)
               : nat_scope.
Notation "x * y" := (mult x y)
               (at level 40, left associativity)
               : nat_scope.


(**  Coqにおける記法のためのそれぞれの記号は、その「優先レベル(precedence level)」と「結合性(associativity)」で記述することが出来ます。優先レベル n は[at level n]というキーワードで記述され、異なるシンボルを含む式の曖昧さを解消する助けになります。結合性は同じシンボルがもっとたくさん出現する式の曖昧さを解消する助けになります。例えば、上記のパラメータであれば、式[1+2*3*4]は式[(1+2((2*3)*4))]の省略された表現であると言うことが出来ます。Coqは、0から100までの優先レベルを使用し、結合性として、left、right、あるいは、noを使用します。

Coqにおける記法のためのそれぞれの記号はまた、記法のスコープのなかで活躍します。Coqは、どんなスコープであるかを推測します。それで、[S*(O*O)]と書かれるときには[nat_scope]であると推測する一方、[bool*bool]型のデカルト積(tuple)が書かれたときには、[type_scope]であると推測します。 まれに[(x*y)%nat]のように書く%記法を使用して、Coqが推測出来るようにしてあげる必要があります。そして時々、Coqはあなたへフィードバックします。[%nat] 何のスコープであるかを指示するために、[%nat]を使用します。

記法のスコープは数の記述にも適用されて、(3,4,5, など) [O]を意味する[0%nat]や、または、整数の0を意味する[0%Z]を見ることが今後あるでしょう。

*)
(** ** [Fixpoint]s と構造再帰 *)

Fixpoint plus' (n : nat) (m : nat) : nat :=
match n with
| O => m
| S n' => S (plus' n' m)
end.

(** Coqがこの定義をチェックする際、evenbが再帰的に呼ばれるとき、最初の引数が減少しているかに注目します。これは、ここでいう再帰がnについて構造的再帰（もしくは原始的再帰）であること、つまりnについて常により少ない値で再帰呼び出しを行っているか、ということです。これはevenbが最終的に停止するということを意味しています。CoqはFixpointキーワードで定義される関数が常にこの「減少性」を持つことを要求します。 

各関数の引数のいくつかが"減少的"でなければならない、という要求仕様は、Coqのデザインにおいて基礎となっているものです。特に、そのことによって、Coq上で作成された関数が、どんな入力を与えられても必ずいつか終了する、ということが保障されています。しかし、Coqの"減少的な解析"が「とても洗練されているとまではいえない」ため、時には不自然な書き方で関数を定義しなければならない、ということもあります。 *)

(** **** 練習問題: ★★, optional (decreasing) *)
(** これを具体的に感じるため、[Fixpoint]で定義された、より「微妙な」関数の書き方を考えてみましょう（自然数に関する簡単な関数でかまいません）。それが全ての入力で停止することと、Coqがそれを、この制限のため受け入れてくれないことを確認しなさい。 *)

(* FILL IN HERE *)
(** [] *)


(* $Date: 2013-07-17 16:19:11 -0400 (Wed, 17 Jul 2013) $ *)
